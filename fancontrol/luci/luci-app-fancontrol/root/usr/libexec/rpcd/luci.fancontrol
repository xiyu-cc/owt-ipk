#!/bin/sh

. /usr/share/libubox/jshn.sh

HWMON_ROOT="/sys/class/hwmon"
RUNTIME_STATUS_FILE_DEFAULT="/var/run/fancontrol.status.json"
PIDFILE_DEFAULT="/var/run/fancontrol.pid"
CONFIG_PATH_DEFAULT="/etc/fancontrol.conf"

sanitize_name() {
	echo "$1" | sed 's/[[:space:]=]/_/g'
}

sanitize_field() {
	printf '%s' "$1" | tr -d '\r\n;' | sed -e 's/^ *//' -e 's/ *$//'
}

read_schema_constant() {
	local key="$1"
	local fallback="$2"
	local payload value=""

	[ -x /usr/sbin/fancontrol ] || {
		echo "$fallback"
		return
	}

	payload="$(/usr/sbin/fancontrol --dump-schema-json 2>/dev/null)"
	[ -n "$payload" ] || {
		echo "$fallback"
		return
	}

	if ! json_load "$payload" >/dev/null 2>&1; then
		echo "$fallback"
		return
	fi

	if json_select constants >/dev/null 2>&1; then
		json_get_var value "$key"
	fi
	json_cleanup

	if [ -n "$value" ]; then
		echo "$value"
	else
		echo "$fallback"
	fi
}

read_first_line() {
	local path="$1"
	local line

	[ -r "$path" ] || return 1
	IFS= read -r line < "$path" || return 1
	echo "$line"
}

rel_from_sys() {
	local path="$1"

	case "$path" in
		/sys/*)
			echo "${path#/sys/}"
		;;
		/sys)
			echo ""
		;;
		*)
			echo "$path"
		;;
	esac
}

first_readable_temp() {
	local hw="$1"
	local f

	for f in "$hw"/temp[0-9]*_input; do
		[ -f "$f" ] || continue
		[ -r "$f" ] || continue
		echo "$f"
		return 0
	done
	return 1
}

first_readable_fan() {
	local hw="$1"
	local f

	for f in "$hw"/fan[0-9]*_input; do
		[ -f "$f" ] || continue
		[ -r "$f" ] || continue
		echo "$f"
		return 0
	done
	return 1
}

json_error() {
	local msg="$1"

	json_init
	json_add_boolean ok 0
	json_add_string error "$msg"
	json_dump
	json_cleanup
}

json_ok() {
	json_init
	json_add_boolean ok 1
	json_dump
	json_cleanup
}

pidfile_is_running() {
	local pidfile="$1"
	local pid=""

	[ -n "$pidfile" ] || return 1
	[ -r "$pidfile" ] || return 1
	IFS= read -r pid < "$pidfile" || return 1
	case "$pid" in
		""|*[!0-9]*)
			return 1
		;;
	esac
	kill -0 "$pid" >/dev/null 2>&1
}

service_is_running() {
	local pidfile="$1"
	local status_text

	if pidfile_is_running "$pidfile"; then
		return 0
	fi
	if /etc/init.d/fancontrol running >/dev/null 2>&1; then
		return 0
	fi

	status_text="$(/etc/init.d/fancontrol status 2>/dev/null | tr 'A-Z' 'a-z' | tr '\n' ' ')"
	case "$status_text" in
		*"not running"*|*"inactive"*|*"stopped"*)
			return 1
		;;
		*"running"*)
			return 0
		;;
	esac

	return 1
}

resolve_pidfile_path() {
	read_schema_constant "pidfile_path" "$PIDFILE_DEFAULT"
}

scan_channels() {
	local hw hwname devname devreal devpath_rel
	local pwm base idx temp fan fan_rel

	json_init
	json_add_array channels

	for hw in "$HWMON_ROOT"/hwmon*; do
		[ -d "$hw" ] || continue
		hwname="$(basename "$hw")"

		devname="$(read_first_line "$hw/name")"
		[ -z "$devname" ] && devname="$(read_first_line "$hw/device/name")"
		[ -z "$devname" ] && devname="$hwname"
		devname="$(sanitize_name "$devname")"

		devreal="$(readlink -f "$hw/device" 2>/dev/null)"
		devpath_rel="$(rel_from_sys "$devreal")"

		for pwm in "$hw"/pwm[0-9]*; do
			[ -f "$pwm" ] || continue
			[ -w "$pwm" ] || continue

			base="$(basename "$pwm")"
			case "$base" in
				pwm[0-9]|pwm[0-9][0-9]*)
				;;
				*)
					continue
				;;
			esac

			idx="${base#pwm}"

			temp="$hw/temp${idx}_input"
			if [ ! -r "$temp" ]; then
				temp="$(first_readable_temp "$hw")"
				[ -n "$temp" ] || continue
			fi

			fan="$hw/fan${idx}_input"
			if [ -r "$fan" ]; then
				fan_rel="${hwname}/$(basename "$fan")"
			else
				fan="$(first_readable_fan "$hw")"
				if [ -n "$fan" ]; then
					fan_rel="${hwname}/$(basename "$fan")"
				else
					fan_rel=""
				fi
			fi

			json_add_object
			json_add_string hwmon_name "$hwname"
			json_add_string devpath_rel "$devpath_rel"
			json_add_string devname "$devname"
			json_add_string pwm_rel "${hwname}/${base}"
			json_add_string temp_rel "${hwname}/$(basename "$temp")"
			json_add_string fan_rel "$fan_rel"
			json_close_object
		done
	done

	json_close_array
	json_dump
	json_cleanup
}

load_board_config() {
	local path
	local payload

	path="$(read_schema_constant "config_path" "$CONFIG_PATH_DEFAULT")"

	[ -x /usr/sbin/fancontrol ] || {
		json_error "fancontrol binary is missing or not executable"
		return
	}

	payload="$(/usr/sbin/fancontrol --dump-effective-config-json "$path" 2>/dev/null)"
	[ -n "$payload" ] || {
		json_error "failed to load board config via fancontrol"
		return
	}

	if ! json_load "$payload" >/dev/null 2>&1; then
		json_error "fancontrol returned invalid JSON for board config"
		return
	fi

	json_dump
	json_cleanup
}

load_board_defaults() {
	local path
	local payload

	path="$(read_schema_constant "config_path" "$CONFIG_PATH_DEFAULT")"

	[ -x /usr/sbin/fancontrol ] || {
		json_error "fancontrol binary is missing or not executable"
		return
	}

	payload="$(/usr/sbin/fancontrol --dump-default-config-json "$path" 2>/dev/null)"
	[ -n "$payload" ] || {
		json_error "failed to load board defaults via fancontrol"
		return
	}

	if ! json_load "$payload" >/dev/null 2>&1; then
		json_error "fancontrol returned invalid JSON for board defaults"
		return
	fi

	json_dump
	json_cleanup
}

load_board_schema() {
	local payload

	[ -x /usr/sbin/fancontrol ] || {
		json_error "fancontrol binary is missing or not executable"
		return
	}

	payload="$(/usr/sbin/fancontrol --dump-schema-json 2>/dev/null)"
	[ -n "$payload" ] || {
		json_error "failed to load board schema via fancontrol"
		return
	}

	if ! json_load "$payload" >/dev/null 2>&1; then
		json_error "fancontrol returned invalid JSON for board schema"
		return
	fi

	json_dump
	json_cleanup
}

apply_board_config_payload() {
	local payload="$1"
	local config_path
	local err

	config_path="$(read_schema_constant "config_path" "$CONFIG_PATH_DEFAULT")"

	[ -x /usr/sbin/fancontrol ] || {
		json_error "fancontrol binary is missing or not executable"
		return
	}

	err="$(printf '%s' "$payload" | /usr/sbin/fancontrol --apply-config-json "$config_path" 2>&1 >/dev/null)"
	if [ "$?" -ne 0 ]; then
		err="$(sanitize_field "$err")"
		[ -n "$err" ] || err="failed to apply board configuration"
		json_error "$err"
		return
	fi

	json_ok
}

runtime_status() {
	local status_file
	local pidfile running=0
	local payload
	local ts now age="" stale=0 info=""

	status_file="$(read_schema_constant "runtime_status_path" "$RUNTIME_STATUS_FILE_DEFAULT")"

	pidfile="$(resolve_pidfile_path)"
	service_is_running "$pidfile" && running=1

	[ -r "$status_file" ] || {
		json_init
		json_add_boolean ok 1
		json_add_boolean running "$running"
		if [ "$running" -eq 1 ]; then
			json_add_string info "fancontrol is running, but runtime status file is not available yet"
		else
			json_add_string info "fancontrol service is not running"
		fi
		json_add_object pwm
		json_close_object
		json_add_object safety
		json_close_object
		json_add_array sources
		json_close_array
		json_dump
		json_cleanup
		return
	}

	payload="$(cat "$status_file" 2>/dev/null)"
	[ -n "$payload" ] || {
		json_init
		json_add_boolean ok 1
		json_add_boolean running "$running"
		json_add_string info "runtime status is empty"
		json_add_object pwm
		json_close_object
		json_add_object safety
		json_close_object
		json_add_array sources
		json_close_array
		json_dump
		json_cleanup
		return
	}

	if ! json_load "$payload" >/dev/null 2>&1; then
		json_init
		json_add_boolean ok 1
		json_add_boolean running "$running"
		json_add_string info "runtime status is not valid JSON"
		json_add_object pwm
		json_close_object
		json_add_object safety
		json_close_object
		json_add_array sources
		json_close_array
		json_dump
		json_cleanup
		return
	fi

	json_get_var ts timestamp
	case "$ts" in
		''|*[!0-9]*)
			age=""
		;;
		*)
			now="$(date +%s 2>/dev/null)"
			case "$now" in
				''|*[!0-9]*)
					age=""
				;;
				*)
					age=$((now - ts))
					[ "$age" -lt 0 ] && age=0
				;;
			esac
		;;
	esac

	if [ "$running" -ne 1 ]; then
		stale=1
		info="fancontrol service is not running; runtime status may be stale"
	elif [ -n "$age" ] && [ "$age" -gt 15 ]; then
		stale=1
		info="runtime status is stale (${age}s old)"
	fi

	json_add_boolean running "$running"
	json_add_boolean stale "$stale"
	[ -n "$age" ] && json_add_int age_s "$age"
	[ -n "$info" ] && json_add_string info "$info"
	json_dump
	json_cleanup
}

service_action() {
	local action="$1"
	local cmd

	case "$action" in
		start|restart|enable)
			cmd="/etc/init.d/fancontrol $action"
		;;
		*)
			json_error "unsupported action"
			return
		;;
	esac

	if eval "$cmd" >/dev/null 2>&1; then
		json_ok
	else
		json_error "service action failed"
	fi
}

case "$1" in
	list)
		json_init
		json_add_object scan
		json_close_object
		json_add_object loadBoardConfig
		json_close_object
		json_add_object loadBoardDefaults
		json_close_object
		json_add_object loadBoardSchema
		json_close_object
		json_add_object applyBoardConfig
			json_add_string interval "string"
			json_add_string control_mode "string"
			json_add_string pwm_path "string"
			json_add_string pwm_enable_path "string"
			json_add_string control_mode_path "string"
			json_add_string pwm_min "string"
			json_add_string pwm_max "string"
			json_add_string ramp_up "string"
			json_add_string ramp_down "string"
			json_add_string hysteresis_mC "string"
			json_add_string failsafe_pwm "string"
			json_add_string sources "array"
		json_close_object
		json_add_object runtimeStatus
		json_close_object
		json_add_object serviceAction
			json_add_string action "string"
		json_close_object
		json_dump
		json_cleanup
	;;
	call)
		case "$2" in
			scan)
				scan_channels
			;;
			loadBoardConfig)
				load_board_config
			;;
			loadBoardDefaults)
				load_board_defaults
			;;
			loadBoardSchema)
				load_board_schema
			;;
			applyBoardConfig)
				read -r input
				apply_board_config_payload "$input"
			;;
			runtimeStatus)
				runtime_status
			;;
			serviceAction)
				read -r input
				json_load "$input"
				json_get_var action action
				json_cleanup
				service_action "$action"
			;;
		esac
	;;
esac
